import java.util.*;

public class Assign1 {

    // -------------------- CAESAR CIPHER --------------------
    public static String caesarEncrypt(String text, int shift) {
        StringBuilder ans = new StringBuilder();
        for (char ch : text.toCharArray()) {
            if (Character.isLetter(ch)) {
                char base = Character.isUpperCase(ch) ? 'A' : 'a';
                ans.append((char) ((ch - base + shift) % 26 + base));
            } else ans.append(ch);
        }
        return ans.toString();
    }

    public static String caesarDecrypt(String text, int shift) {
        StringBuilder ans = new StringBuilder();
        for (char ch : text.toCharArray()) {
            if (Character.isLetter(ch)) {
                char base = Character.isUpperCase(ch) ? 'A' : 'a';
                ans.append((char) ((ch - base - shift + 26) % 26 + base));
            } else ans.append(ch);
        }
        return ans.toString();
    }

    // -------------------- MONOALPHABETIC CIPHER --------------------
    public static String monoEncrypt(String text, String key) {
        StringBuilder ans = new StringBuilder();
        text = text.toUpperCase();
        key = key.toUpperCase();
        for (char ch : text.toCharArray()) {
            if (Character.isLetter(ch)) ans.append(key.charAt(ch - 'A'));
            else ans.append(ch);
        }
        return ans.toString();
    }

    public static String monoDecrypt(String text, String key) {
        StringBuilder ans = new StringBuilder();
        text = text.toUpperCase();
        key = key.toUpperCase();
        for (char ch : text.toCharArray()) {
            if (Character.isLetter(ch)) ans.append((char) (key.indexOf(ch) + 'A'));
            else ans.append(ch);
        }
        return ans.toString();
    }

    // -------------------- POLYALPHABETIC (VIGENÈRE) CIPHER --------------------
    public static String polyEncrypt(String text, String key) {
        StringBuilder ans = new StringBuilder();
        text = text.toUpperCase();
        key = key.toUpperCase();
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (Character.isLetter(c)) {
                char k = key.charAt(i % key.length());
                ans.append((char) (((c - 'A') + (k - 'A')) % 26 + 'A'));
            } else ans.append(c);
        }
        return ans.toString();
    }

    public static String polyDecrypt(String text, String key) {
        StringBuilder ans = new StringBuilder();
        text = text.toUpperCase();
        key = key.toUpperCase();
        for (int i = 0; i < text.length(); i++) {
            char c = text.charAt(i);
            if (Character.isLetter(c)) {
                char k = key.charAt(i % key.length());
                ans.append((char) (((c - 'A') - (k - 'A') + 26) % 26 + 'A'));
            } else ans.append(c);
        }
        return ans.toString();
    }

    // -------------------- RAIL FENCE CIPHER --------------------
    public static String railEncrypt(String text, int rails) {
        List<StringBuilder> rail = new ArrayList<>();
        for (int i = 0; i < rails; i++) rail.add(new StringBuilder());
        int row = 0, dir = 1;
        for (char c : text.toCharArray()) {
            rail.get(row).append(c);
            if (row == 0) dir = 1;
            else if (row == rails - 1) dir = -1;
            row += dir;
        }
        StringBuilder result = new StringBuilder();
        for (StringBuilder sb : rail) result.append(sb);
        return result.toString();
    }

    public static String railDecrypt(String cipher, int rails) {
        int len = cipher.length();
        int[] railLen = new int[rails];
        int row = 0, dir = 1;

        // Count characters per rail
        for (int i = 0; i < len; i++) {
            railLen[row]++;
            if (row == 0) dir = 1;
            else if (row == rails - 1) dir = -1;
            row += dir;
        }

        // Split cipher into rail segments
        List<String> railsData = new ArrayList<>();
        int index = 0;
        for (int lenPart : railLen) {
            railsData.add(cipher.substring(index, index + lenPart));
            index += lenPart;
        }

        // Reconstruct zigzag pattern
        int[] pos = new int[rails];
        row = 0;
        dir = 1;
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < len; i++) {
            result.append(railsData.get(row).charAt(pos[row]++));
            if (row == 0) dir = 1;
            else if (row == rails - 1) dir = -1;
            row += dir;
        }
        return result.toString();
    }

    // -------------------- VERNAM CIPHER (TRUE XOR VERSION) --------------------
    public static String vernamEncrypt(String text, String key) {
        if (key.length() < text.length()) {
            throw new IllegalArgumentException("Key must be at least as long as text for Vernam Cipher.");
        }
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < text.length(); i++) {
            char encryptedChar = (char) (text.charAt(i) ^ key.charAt(i)); // XOR
            result.append(encryptedChar);
        }
        return result.toString();
    }

    public static String vernamDecrypt(String cipher, String key) {
        if (key.length() < cipher.length()) {
            throw new IllegalArgumentException("Key must be at least as long as cipher for Vernam Cipher.");
        }
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < cipher.length(); i++) {
            char decryptedChar = (char) (cipher.charAt(i) ^ key.charAt(i)); // XOR again
            result.append(decryptedChar);
        }
        return result.toString();
    }

    // -------------------- MAIN MENU --------------------
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        boolean again;

        do {
            System.out.println("\n=== ENCRYPTION ALGORITHMS MENU ===");
            System.out.println("1. Caesar Cipher");
            System.out.println("2. Monoalphabetic Cipher");
            System.out.println("3. Polyalphabetic (Vigenère) Cipher");
            System.out.println("4. Rail Fence Cipher");
            System.out.println("5. Vernam Cipher (XOR)");
            System.out.print("Select option (1–5): ");

            int choice = sc.nextInt();
            sc.nextLine(); // clear input buffer

            String text, key;
            int shift, rails;

            System.out.print("Enter text: ");
            text = sc.nextLine();

            switch (choice) {
                case 1 -> {
                    System.out.print("Enter shift value: ");
                    shift = sc.nextInt();
                    sc.nextLine();
                    String enc = caesarEncrypt(text, shift);
                    System.out.println("Encrypted: " + enc);
                    System.out.println("Decrypted: " + caesarDecrypt(enc, shift));
                }

                case 2 -> {
                    System.out.println("Enter 26-letter key (A–Z only): ");
                    while (true) {
                        key = sc.next();
                        if (!key.matches("[a-zA-Z]+") || key.length() != 26)
                            System.out.println("Invalid key! Must have exactly 26 letters.");
                        else break;
                    }
                    String enc = monoEncrypt(text, key);
                    System.out.println("Encrypted: " + enc);
                    System.out.println("Decrypted: " + monoDecrypt(enc, key));
                }

                case 3 -> {
                    System.out.print("Enter alphabetic key: ");
                    key = sc.next();
                    String enc = polyEncrypt(text, key);
                    System.out.println("Encrypted: " + enc);
                    System.out.println("Decrypted: " + polyDecrypt(enc, key));
                }

                case 4 -> {
                    System.out.print("Enter number of rails (>1): ");
                    rails = sc.nextInt();
                    sc.nextLine();
                    String enc = railEncrypt(text, rails);
                    System.out.println("Encrypted: " + enc);
                    System.out.println("Decrypted: " + railDecrypt(enc, rails));
                }

                case 5 -> {
                    System.out.print("Enter key (same length or longer than text): ");
                    key = sc.nextLine();

                    if (key.length() < text.length()) {
                        System.out.println("Error: Key must be at least as long as text!");
                        break;
                    }

                    String enc = vernamEncrypt(text, key);
                    System.out.println("Encrypted (raw): " + enc);

                    // Optional readable view (ASCII values)
                    System.out.print("Encrypted (ASCII): ");
                    for (char ch : enc.toCharArray()) System.out.print((int) ch + " ");
                    System.out.println();

                    String dec = vernamDecrypt(enc, key);
                    System.out.println("Decrypted: " + dec);
                }

                default -> System.out.println("Invalid choice! Select 1–5.");
            }

            System.out.print("\nDo you want to continue? (1 for Yes / 0 for No): ");
            again = sc.nextInt() == 1;
            sc.nextLine();

        } while (again);

        System.out.println("Exiting program. Goodbye!");
        sc.close();
    }
}
